<?php

/**
 * ProcessWire
 * Copyright (C) 2014-present by Ryan Cramer
 * Licensed under GNU/GPL v2, see LICENSE.TXT
 *
 * http://processwire.com
 *
 *
 * TODO
 * ----
 * Fix scrolling on long entries.
 *
 * Add caching to help circumvent hitting hosting service API rate limits
 * Add support for Gitlab hosted repositories via repo-host abstraction
 * Add support for BitBucket hosted repositories via repo-host abstraction
 * Move support for GitHub into repo-host abstraction
 * Add public data-access API for other modules to use
 * Add highlighting of breaking changes.
 *
 * Known Issues
 * ------------
 *
 */

class ModuleReleaseNotes extends Process implements ConfigurableModule {


    protected $github_remaining_reads = 60;


    public static function getModuleInfo() {
        return [
            'title'     => __('Module Release Notes'),
            'summary'   => __("Discovers and shows what has changed with each module version."),
            'version'   => '0.3.3',
            'author'    => 'Stephen Dickinson (netcarver)',
            'autoload'  => 'template=admin',
            'singular'  => true,
            'permanent' => false,
            'requires'  => 'ProcessWire>=3.0.0, PHP>=5.4.0',
            'installs'  => 'TextformatterParsedownExtraPlugin',
            'icon'      => 'code-fork'
        ];
    }


    /**
     *
     */
    static public function getDefaultConfig() {
        return [
            'fallbackCommitHistory' => 12,
            'openSettings'          => 0,
            'wordWrapColumn'        => 95,
        ];
    }


    /**
     * Lists mappings of file extensions to markup language and preferred textformatter to be used.
     *
     * Anything not matching the list here (or if the formatter fails to be loaded) will be escaped and output
     * 'verbatim'.
     */
    static $formatters = [
        'md' => ['type' => 'Markdown', 'use' => 'TextformatterParsedownExtraPlugin'],
    ];


    /**
     * Make config data available within the instance variable.
     */
    public function __construct() {
        foreach(self::getDefaultConfig() as $key => $value) {
            $this->$key = $value;
        }
    }


    /**
     * Prepares commit meta-data for display
     */
    public function formatCommitMetaData($commit, $info) {
        $author    = $commit['commit']['author']['name'];
        $committer = $commit['commit']['committer']['name'];
        $date      = $commit['commit']['committer']['date'];
        $sha       = substr($commit['sha'], 0, 8);
        $diff_url  = $commit['html_url'];
        $icon      = $info['repo_icon'];

        $date  = str_replace('T', ' ', $date);
        $sig   = "$icon &mdash; $date &mdash; <a href='$diff_url' target='_diff'>$sha <i class='fa fa-icon fa-external-link'></i></a> &mdash; $author";

        return $sig;
    }




    /**
     * Get githubs ReleaseNotes entry for the given module.
     *
     * As far as I know, this is only applicable to repos hosted at Github.
     * TODO rework to operate in the same manner as the other getters.
     */
    public function getReleaseNotes($info, &$http) {
        // TODO add caching (stop us from hitting API request limits
        // Look for release notes
        $remote = $info['project_url'];
        $api_remote = str_replace('https://github.com/', 'https://api.github.com/repos/', $remote);
        $url = "$api_remote/releases/tags/{$info['module_version']}";
        $result = $http->getJSON($url);
        $this->recordRemainingReads($http);
        return $result;
    }


    /**
     * Sanitise a string for further processing and display.
     *
     * If you are going to be passing the string to a ML like Markdown or Textile, you might want to do an entity_decode
     * first to cause HTML entities to be mapped to utf-8 characters where possible. This will allow for text with
     * diacritics/non ASCII characters to appear as they should and not as embedded HTML Entities.
     *
     * TODO Perhaps use some JS to clean up these from code blocks in certain divs.
     */
    public function sanitizeString($string) {
        $san = wire('sanitizer');
        $string = $san->purify($string);
        return $string;
    }



    /**
     *
     */
    public function getTaggedLog($info, &$http, &$tagged_log) {
        // TODO add caching (stop us from hitting API request limits
        $remote = $info['project_url'];
        $api_remote = str_replace('https://github.com/', 'https://api.github.com/repos/', $remote);
        $url = "$api_remote/compare/{$info['module_version_current']}...{$info['module_version']}";
        $tmp_result = $http->getJSON($url);
        $this->recordRemainingReads($http);
        $code = $http->getHttpCode();
        if(200 == $code && !empty($tmp_result['commits'])) {
            $history = [];
            $commits = $tmp_result['commits'];
            foreach ($commits as $commit) {
                $message   = $this->sanitizeString($commit['commit']['message']);
                $message   = $this->utf8_wordwrap($message);
                $sig       = $this->formatCommitMetaData($commit, $info);
                $entry     = "<li class='commit'><span class='sig'>$sig</span><br><pre>$message</pre></li>";
                $history[] = $entry;
            }
            $history   = implode("", $history);
            $diff_url  = $tmp_result['html_url'];
            $diff_link = "(<a href='$diff_url' target='_diff'>View diff. {$info['remote_icon']}</i></a>)";
            $tagged_log = "<ul>$history</ul><p><a href='$diff_url' target='_diff'>{$info['repo_icon']} View Entire Diff.</a></p>";
        }
    }



    /**
     * Get the changelog file for the given module.
     *
     * Currently only knows about Github.
     */
    public function getChangelog($info, &$http, &$changelog) {
        $remote = $info['project_url'];
        $raw_remote = str_replace('https://github.com/', 'https://raw.githubusercontent.com/', $remote);
        $url = "$raw_remote/master/CHANGELOG.md";
        $result = $http->get($url);
        $this->recordRemainingReads($http);
        if(200 == $http->getHttpCode()) {
            $changelog = $result;
        }
    }



    /**
     * Examine the remote URL to determine the hosting service and icon to use.
     */
    public function remoteHostInfo($remote) {
        if (false !== stripos($remote, '://github.com')) {
            return [
                'host' => 'Github',
                'link' => $remote,
                'icon' => '<i class="fa fa-icon fa-github"></i>',
            ];
        } else if (false !== stripos($remote, '://bitbucket.org')) {
            return [
                'host' => 'BitBucket',
                'link' => $remote,
                'icon' => '<i class="fa fa-icon fa-bitbucket"></i>'
            ];
        } else if (false !== stripos($remote, '://gitlab.com')) {
            return [
                'host' => 'GitLab',
                'link' => $remote,
                'icon' => '<i class="fa fa-icon fa-gitlab"></i>'
            ];
        }

        // Use a generic git icon...
        return [
            'host' => 'Unknown',
            'link' => $remote,
            'icon' => '<i class="fa fa-icon fa-git"></i>',
        ];
    }



    /**
     * Pulls the x-ratelimit headers from Github.
     */
    protected function recordRemainingReads($http) {
        $headers = $http->getResponseHeaders();
        if (isset($headers['x-ratelimit-remaining'])) {
            $this->github_remaining_reads = [
                'limit'     => $headers['x-ratelimit-limit'],
                'remaining' => $headers['x-ratelimit-remaining'],
                'reset'     => $headers['x-ratelimit-reset'],
            ];
        }
    }


    /**
     * Pulls the last N commits for the given module.
     *
     * Currently only knows about Github.
     */
    public function getLastCommits($info, &$http, &$latest_commits) {
        $remote = $info['project_url'];
        $api_remote = str_replace('https://github.com/', 'https://api.github.com/repos/', $remote);
        $url = "$api_remote/commits";
        $result = $http->getJSON($url);
        $this->recordRemainingReads($http);
        $code = $http->getHttpCode();
        if(200 == $code && !empty($result)) {
            $history = [];
            $commits = array_slice($result, 0, $this->data['fallbackCommitHistory']);
            foreach ($commits as $commit) {
                $message   = $this->sanitizeString($commit['commit']['message']);
                $message   = $this->utf8_wordwrap($message);
                $sig       = $this->formatCommitMetaData($commit, $info);
                $entry     = "<li class='commit'><span class='sig'>$sig</span><br><pre>$message</pre></li>";
                $history[] = $entry;
            }
            $history   = implode("", $history);
            $latest_commits = "<ul>$history</ul>";
        }
    }


    /**
     * Add hooks to display release information to modules prior to upgrade and add the readme and changelog to module
     * information pages.
     */
    public function ready() {

        if (!$this->user->isLoggedin() || !$this->user->hasPermission('module-admin')) return;

        /**
         * Inject common stylesheet into download confirm page
         */
        $this->addHookAfter("ProcessModule::execute", function($event) {
            $event->return = self::getEmbeddedStyles() . $event->return;
        });

        /**
         * Add Release notes and/or a list of commits between tags and/or the latest changelog and/or the latest
         * commit messages to the download confirmation form.
         */
        $this->addHookAfter("ProcessModule::buildDownloadConfirmForm", function($event) {
            $info            = $event->arguments[0];
            $module_class    = $info['class_name'];
            $current_info    = $this->modules->getModuleInfo($module_class);
            $current_version = $current_info['version'];
            $new_version     = $info['module_version'];
            $remote          = $info['project_url'];
            $remote_info     = $this->remoteHostInfo($remote);
            $repo_icon       = $remote_info['icon'];
            $remote_icon     = '<i class="fa fa-icon fa-external-link"></i>';
            $is_github_repo  = (false !== stripos($remote, '://github.com'));

            // Push the current version into the $info
            $info['version_current'] = $current_version;
            if (is_int($current_version)) {
                $current_version = $this->modules->formatVersion($current_version);
            }
            $info['module_version_current'] = $current_version;
            $info['repo_icon']   = $repo_icon;
            $info['remote_icon'] = $remote_icon;
            ksort($info);

            $changes         = $current_version != $new_version;

            $http = new WireHttp();
            $http->setHeader('User-Agent', 'netcarver-pw-module-version-checker');
            $http->setTimeout(2);

            $return_info     = $event->return;
            $children        = $return_info->children;


            $wrapper = $this->modules->get('InputfieldFieldset');
            $wrapper->name  = 'changes-wrapper';
            $wrapper->label = __("What's Changed?");

            $release_notes  = $release_notes_default  = __('Not Available - Github Release Not Found');
            $tagged_log     = $tagged_log_default     = __('Not Available - One or More Git Tags Missing');
            $changelog_file = $changelog_file_default = __('Not Available - File Missing');
            $latest_commits = $latest_commits_default = __('Comming Soon!');

            //
            // Fetch release notes (if any)...
            //
            // TODO Only show release notes for Github repos. BB and GL repos don't support them.
            //
            $tmp_release_notes = $this->getReleaseNotes($info, $http);
            $code = $http->getHttpCode();
            if(200 == $code && !empty($tmp_release_notes['body'])) {
                // TODO Handle non 200 return codes, or empty body!
                // TODO It is possible for the requests to be refused due to rate-limiting - this needs to be conveyed to the
                // user
                $release_notes = $this->formatTextOfType('md', $tmp_release_notes['body'], $fmt_note);
                $release_link  = "$remote/releases/tag/$new_version";
            }
            $has_release_notes = $release_notes != $release_notes_default;

            //
            // Fetch tagged log (if any)...
            //
            if ($changes) {
                $this->getTaggedLog($info, $http, $tagged_log);
            }
            $has_tagged_log = $tagged_log != $tagged_log_default;

            //
            // Fetch changelog file (if any)...
            //
            $this->getChangelog($info, $http, $changelog_file);
            $has_changelog_file = $changelog_file != $changelog_file_default;


            $field = $this->modules->get('InputfieldMarkup');
            $field->name = 'release-notes';
            if ($has_release_notes) {
                $field->label  = __("Official Release Notes for $new_version.");
                $release_notes = "<div class='module-release-notes'>$release_notes<p><a href='$release_link' target='_diff'>$repo_icon View</a><p></div>";
                $field->notes  = $fmt_note;
            } else {
                $field->label = __("No Official Release Notes for $new_version.");
                $field->notes = __('To add official release notes, please ask the module author to start using the Github [Releases](https://help.github.com/articles/creating-releases/) feature. They will have to start [tagging](https://git-scm.com/book/en/v2/Git-Basics-Tagging) the code as they push new versions in order to use this feature.');
                if ($has_changelog_file || $has_tagged_log) {
                    $field->collapsed = Inputfield::collapsedYes;
                }
            }
            $field->value = $release_notes;
            $wrapper->add($field);

            if ($changes) {
                $field = $this->modules->get('InputfieldMarkup');
                $field->name = 'tagged-log';
                if ($has_tagged_log) {
                    $field->label = __("Detailed Commit History - from $current_version to $new_version");
                } else {
                    $field->label = __("No Detailed Commit History Available");
                    $field->notes = __('Even if the author doesn\'t use Github Releases (perhaps they are using Bitbucket or Gitlab), they can start to show code changes between versions if they start [tagging](https://git-scm.com/book/en/v2/Git-Basics-Tagging) each commit that increments the module version. The tags **must** match the version numbering scheme used by the module for this feature to work.');
                    if ($has_changelog_file) {
                        $field->collapsed = Inputfield::collapsedYes;
                    }
                }
                if ($has_release_notes) {
                    $field->collapsed = Inputfield::collapsedYes;
                }
                $field->value = "<div class='module-release-notes'>$tagged_log</div>";
                $wrapper->add($field);
            }

            if (!$has_release_notes || $has_changelog_file) {
                // If there are no release notes, or there is a changelog file, we show this field.
                $field = $this->modules->get('InputfieldMarkup');
                $field->name = 'changelog';
                if ($has_changelog_file) {
                    $field->label   = __("Changelog from version $new_version");
                    $changelog_file = $this->formatTextOfType('md', $changelog_file, $fmt_note);
                    $field->notes   = $fmt_note;
                    $changelog_file = "<div class='module-release-notes'>$changelog_file</div>";
                } else {
                    $field->label   = __("No Changelog from version $new_version");
                    $field->notes   = __('If the author does not want to tag versions or cut releases, then they could consider adding (and maintaining) a ```CHANGELOG``` file in the root of the module repository. If they do, it will show up here. If they already use the releases feature, or tag module versions, this is not necessary and can lead to duplicated effort.');
                }
                if ($has_release_notes) {
                    $field->collapsed = Inputfield::collapsedYes;
                }
                $field->value = $changelog_file;
                $wrapper->add($field);
            }

            if (!$has_release_notes && !$has_tagged_log && !$has_changelog_file) {

                $this->getLastCommits($info, $http, $latest_commits);
                $has_latest_commits = $latest_commits != $latest_commits_default;

                $field = $this->modules->get('InputfieldMarkup');
                $field->name = 'commit-log';
                $field->label = $this->data['fallbackCommitHistory'] . ' ' . __("Most Recent Commits");
                if (!$has_latest_commits) {
                    $field->notes = __('Please ask the author to add support for one of the above options, as this list is simply the most recent Git commit message log. Adding and maintaining a ```CHANGELOG.md``` file is a step-up. Tagging git commits at each new version is better still, as it allows automatic diffing between versions. If on Github, using the Releases feature is a nice step up.');
                }
                $field->value = "<div class='module-release-notes'>$latest_commits</div>";
                $wrapper->add($field);
            }

            $wrapper->notes = __("Github API reads remaining: ") . $this->github_remaining_reads['remaining'] .'/'. $this->github_remaining_reads['limit'] . '. ' .
                __('Resets at ') .strftime('%F %T', $this->github_remaining_reads['reset']);

            $return_info->children->insertAfter($wrapper, $children[0]);
        });



        /**
         * Display README and CHANGELOG sections on all module information pages, if these files exist in the
         * installation. This allows access to a level of help for modules that wasn't there before.
         */
        $this->addHookAfter("ProcessModule::executeEdit", function($event) {
            $info         = null;
            $module_class = '';
            $append_info  = false;

            if (isset($_POST['name'])) {
                $module_class = $_POST['name'];
            } elseif (isset($_GET['name'])) {
                $module_class = $_GET['name'];
            }
            $module_class = $this->sanitizer->name($module_class);
            $info = $this->modules->getModuleInfoVerbose($module_class);


            $outer_wrapper = new InputfieldWrapper();
            $wrapper = $this->modules->get('InputfieldFieldset');
            $wrapper->name  = 'changes-wrapper';
            $wrapper->label = __("Support Files");
            $wrapper->icon  = 'file-text-o';
            $wrapper->collapsed = $this->data['openSettings'] ? Inputfield::collapsedNo : Inputfield::collapsedYes;

            $dir = dirname(realpath($info['file']));

            $readmes = glob($dir.DIRECTORY_SEPARATOR."[Rr][Ee][Aa][Dd][Mm][Ee]*");
            foreach ($readmes as $filename) {
                $content = $this->getFormattedTextFromFile($filename, $formatting_notes);
                if (!$content) continue;
                $basename = basename($filename);
                $wrapper->add(self::wrapValueInField('readme', $content, $basename, 'book', $formatting_notes));
                $append_info = true;
            }

            $changelogs = glob($dir.DIRECTORY_SEPARATOR."[Cc][Hh][Aa][Nn][Gg][Ee][Ll][Oo][Gg]*");
            foreach ($changelogs as $filename) {
                $content = $this->getFormattedTextFromFile($filename, $formatting_notes);
                if (!$content) continue;
                $basename = basename($filename);
                $wrapper->add(self::wrapValueInField('changelog', $content, $basename, 'tags', $formatting_notes));
                $append_info = true;
            }

            $licensefiles = glob($dir.DIRECTORY_SEPARATOR."[Ll][Ii][Cc][Ee][Nn][SsCc][Ee]*");
            foreach ($licensefiles as $filename) {
                $content = $this->getFormattedTextFromFile($filename, $formatting_notes);
                if (!$content) continue;
                $basename = basename($filename);
                $wrapper->add(self::wrapValueInField('license', $content, $basename, 'balance-scale', $formatting_notes));
                $append_info = true;
            }

            if ($append_info) {
                $outer_wrapper->add($wrapper);
                $module_page   = $event->return;
                $styles        = self::getEmbeddedStyles();
                $event->return = $styles. $outer_wrapper->render() . $module_page;
            }
        });
    }





    /**
     * Returns a formatter for the given file extension (if possible)
     */
    static function getFormatterForFiletype($ext, &$formatter_info) {
        $ext = strtolower($ext);
        if (empty($ext)) $ext = 'txt';
        $formatter_info = @self::$formatters[$ext];
        $formatter      = null; // null => no load tried. false => load tried and failed.
        if ($formatter_info) {
            $formatter = @$formatter_info['instance'];
            if (null === $formatter) {
                if (is_string($formatter_info['use']) && !empty($formatter_info['use'])) {
                    $formatter = wire('modules')->get($formatter_info['use']);
                }
                self::$formatters[$ext]['instance'] = ($formatter) ? $formatter: false;
            }
        }
        return $formatter;
    }


    /**
     * Given a filename, tries to read and format the content with an appropriate textformatter.
     */
    public function getFormattedTextFromFile($filename, &$transformation_applied) {
        $transformation_applied = __('None');
        if (!is_file($filename) || !is_readable($filename)) return false;
        // Which extension is the file using?
        $ext = strtolower(pathinfo($filename, PATHINFO_EXTENSION));
        if (empty($ext)) $ext = 'txt';
        $content = file_get_contents($filename);
        if (false !== $content && !empty(trim($content))) {
            return $this->formatTextOfType($ext, $content, $transformation_applied);
        }
        return false;
    }


    /**
     * UTF-8 wordwrapping function.
     *
     * Source: http://php.net/manual/en/function.wordwrap.php#107570
     * minor edit to correct variable $search name in else clause.
     */
    protected function utf8_wordwrap($string, $break="\n", $cut=false) {
        $width = $this->wordWrapColumn;
        if($cut) {
            // Match anything 1 to $width chars long followed by whitespace or EOS,
            // otherwise match anything $width chars long
            $search  = '/(.{1,'.$width.'})(?:\s|$)|(.{'.$width.'})/uS';
            $replace = '$1$2'.$break;
        } else {
            // Anchor the beginning of the pattern with a lookahead
            // to avoid crazy backtracking when words are longer than $width
            $search  = '/(?=\s)(.{1,'.$width.'})(?:\s|$)/uS';
            $replace = '$1'.$break;
        }
        return preg_replace($search, $replace, $string);
    }




    /**
     * Tries to apply an appropriate textformatter to a given content string.
     * If no suitable external formatter is available, it will be passed through an internal 'verbatim' formatter.
     *
     * It also records which formatter was applied.
     */
    protected function formatTextOfType($ext, $unsafe_content, &$transformation_applied) {
        $formatter = self::getFormatterForFiletype($ext, $formatter_info);
        if ($formatter) {
            /**
             * Display using formatter. Need to prevent possible XSS vectors here so it is all escaped...
             *
             * We call html_entity_decode() to convert entities to their UTF-8 character versions when possible,
             * before then passing it through htmlspecialchars() to encode angle brackets and quotes. If this is not
             * done then some characters with diacritic marks remain as html entities in the code.
             */
            $formatter->formatValue(new \ProcessWire\Page(), new \ProcessWire\Field(), $unsafe_content);
            $content = $this->sanitizeString($unsafe_content);
            $transformation_applied = sprintf(__("Prepared using the %s formatter."), $formatter_info['type']) . " [$ext]";
        } else {
            /**
             * Display verbatim. Need to prevent possible XSS vectors here so it is all escaped...
             */
            $content = html_entity_decode($unsafe_content, ENT_COMPAT, 'UTF-8');
            $content = htmlspecialchars($content, ENT_COMPAT, 'UTF-8');
            $content = $this->utf8_wordwrap($content);
            $content = "<pre>$content</pre>";

            if ($formatter_info) {
                /**
                 * formatter_info existing shows we had a textformatter entry for this filetype but couldn't load it
                 */
                $transformation_applied = sprintf(
                    __("Prepared using verbatim formatter because the %s formatter [%s] is not available."),
                    $formatter_info['type'],
                    $formatter_info['use']
                ) . " [$ext]";
            } else {
                $transformation_applied = __("Prepared using verbatim formatter.") . " [$ext]";
            }
        }
        return $content;
    }



    /**
     */
    static function getEmbeddedStyles() {
        $value = <<<CSS
<style>
.module-release-notes {overflow-x:overlay;padding-bottom:1em}
.module-release-notes h1 {margin-top:1em !important; font-size:1.5em;padding-bottom:0.2em;border-bottom:1px solid #eaecef}
.module-release-notes h2 {margin-top:1em;padding-bottom:0.2em;border-bottom:1px solid #eaecef}
.module-release-notes li {margin:0}
.module-release-notes ul {margin-bottom:2em}
.module-release-notes strong {font-weight:700}
.module-release-notes em {font-style:italic}
.module-release-notes span.sig {font-family:monospace}
.module-release-notes li.commit {padding-bottom:1em}
</style>
CSS;

        return $value;
    }



    /**
     * Builds a markup input field to contain the given information.
     */
    static function wrapValueInField($name, $value, $label, $icon, $notes) {
        $value = "<div class='module-release-notes'>$value</div>";
        $f = wire('modules')->get('InputfieldMarkup');
        $f->name = $name;
        $f->label = $label;
        $f->notes = $notes;
        $f->value = $value;
        $f->collapsed = Inputfield::collapsedYes;
        $f->icon = $icon;
        return $f;
    }


    /**
     *
     */
    public function init() {
        parent::init();
    }



    /**
     *
     */
    static public function getModuleConfigInputfields(array $data) {

        $modules   = wire('modules');
        $fields    = new InputfieldWrapper();
        $defaults  = self::getDefaultConfig();
        $data      = array_merge($defaults, $data);

        $f = $modules->get('InputfieldInteger');
        $f->attr('name', 'fallbackCommitHistory');
        $f->attr('inputType', 'number');
        $f->attr('type', 'number');
        $f->label = __('Number of Commits To Show');
        $f->description = __('If there are no Release Notes, Tagged Commits or Changelog, how many lines of commit history should be shown?');
        $f->max = 30;
        $f->min = 2;
        $f->notes = __("Minimum 2, Maximum 30");
        $f->attr('value', $data['fallbackCommitHistory']);
        $fields->add($f);

        $f = $modules->get('InputfieldInteger');
        $f->attr('name', 'wordWrapColumn');
        $f->attr('inputType', 'number');
        $f->attr('type', 'number');
        $f->label = __('Wrap text files at which column position?');
        $f->max = 300;
        $f->min = 40;
        $f->notes = __("Minimum 40, Maximum 300");
        $f->attr('value', $data['wordWrapColumn']);
        $fields->add($f);

        $f = $modules->get('InputfieldRadios');
        $f->attr('name', 'openSettings');
        $f->label = __('Open the "Support Files" section of the module information page automatically');
        $f->addOption(0, __('No, keep it collapsed.'));
        $f->addOption(1, __('Yes, show me the support files.'));
        $f->attr('value', $data['openSettings']);
        $fields->add($f);


        return $fields;
    }


    /**
     * Installs needed resources.
     */
    public function ___install() {
    }

}
