<?php

/**
 * ProcessWire
 * Copyright (C) 2014-present by Ryan Cramer
 * Licensed under GNU/GPL v2, see LICENSE.TXT
 *
 * http://processwire.com
 *
 *
 * TODO
 * ----
 * Bugfix: multiple declaration of $parsedown
 * Bugfix: use of <pre> wrapper insufficient to prevent XSS from displayed readme and changelogs
 * Fix scrolling on long entries.
 *
 * Add caching to help circumvent hitting hosting service API rate limits
 * Add support for Gitlab hosted repositories via repo-host abstraction
 * Add support for BitBucket hosted repositories via repo-host abstraction
 * Move support for GitHub into repo-host abstraction
 * Add public data-access API for other modules to use
 * Add highlighting of breaking changes.
 * Add notes to ___executeInstallConfirm() so they are seen on initial install, not just upgrade and post-install
 *
 * Known Issues
 * ------------
 *
 */

class ModuleReleaseNotes extends Process implements ConfigurableModule {


    protected $github_remaining_reads = 60;


    public static function getModuleInfo() {
        return array(
            'title'     => __('Module Release Notes'),
            'summary'   => __("Discovers and shows what has changed with each module version."),
            'version'   => '0.2.0',
            'author'    => 'Stephen Dickinson (netcarver)',
            'autoload'  => 'template=admin',
            'singular'  => true,
            'permanent' => false,
            'requires'  => 'ProcessWire>=3.0.0, PHP>=5.3.8',
            'installs'  => 'TextformatterParsedownExtraPlugin',
            'icon'      => 'code-fork'
        );
    }


    /**
     *
     */
    static public function getDefaultConfig() {
        return array(
            'fallbackCommitHistory' => 12,
        );
    }


    /**
     * Make config data available within the instance variable.
     */
    public function __construct() {
        foreach(self::getDefaultConfig() as $key => $value) {
            $this->$key = $value;
        }
    }


    /**
     * Prepares commit meta-data for display
     */
    public function formatCommitMetaData($commit, $info) {
        $author    = $commit['commit']['author']['name'];
        $committer = $commit['commit']['committer']['name'];
        $date      = $commit['commit']['committer']['date'];
        $sha       = substr($commit['sha'], 0, 8);
        $diff_url  = $commit['html_url'];
        $icon      = $info['repo_icon'];

        $date  = str_replace('T', ' ', $date);
        $sig   = "$icon &mdash; $date &mdash; <a href='$diff_url' target='_diff'>$sha <i class='fa fa-icon fa-external-link'></i></a> &mdash; $author";

        return $sig;
    }




    /**
     * Get githubs ReleaseNotes entry for the given module.
     *
     * As far as I know, this is only applicable to repos hosted at Github.
     * TODO rework to operate in the same manner as the other getters.
     */
    public function getReleaseNotes($info, &$http) {
        // TODO add caching (stop us from hitting API request limits
        // Look for release notes
        $remote = $info['project_url'];
        $api_remote = str_replace('https://github.com/', 'https://api.github.com/repos/', $remote);
        $url = "$api_remote/releases/tags/{$info['module_version']}";
        $result = $http->getJSON($url);
        $this->recordRemainingReads($http);
        return $result;
    }


    /**
     * Sanitise a string for further processing and display.
     *
     * If you are going to be passing the string to a ML like Markdown or Textile, you might want to do an entity_decode
     * first to cause HTML entities to be mapped to utf-8 characters where possible. This will allow for text with
     * diacritics/non ASCII characters to appear as they should and not as embedded HTML Entities.
     *
     */
    public function sanitizeString($string, $entity_decode = false) {
        if ($entity_decode) {
            $string = html_entity_decode($string, ENT_COMPAT, 'UTF-8');
        }
        return htmlspecialchars($string, ENT_COMPAT, 'UTF-8');
    }



    /**
     *
     */
    public function getTaggedLog($info, &$http, &$tagged_log) {
        // TODO add caching (stop us from hitting API request limits
        $remote = $info['project_url'];
        $api_remote = str_replace('https://github.com/', 'https://api.github.com/repos/', $remote);
        $url = "$api_remote/compare/{$info['module_version_current']}...{$info['module_version']}";
        $tmp_result = $http->getJSON($url);
        $this->recordRemainingReads($http);
        $code = $http->getHttpCode();
        if(200 == $code && !empty($tmp_result['commits'])) {
            $history = array();
            $commits = $tmp_result['commits'];
            foreach ($commits as $commit) {
                $message   = $this->sanitizeString($commit['commit']['message']);
                $message   = wordwrap($message);
                $sig       = $this->formatCommitMetaData($commit, $info);
                $entry     = "<li>$sig<br><pre>$message</pre></li>";
                $history[] = $entry;
            }
            $history   = implode("", $history);
            $diff_url  = $tmp_result['html_url'];
            $diff_link = "(<a href='$diff_url' target='_diff'>View diff. {$info['remote_icon']}</i></a>)";
            $tagged_log = "<ul>$history</ul><p><a href='$diff_url' target='_diff'>{$info['repo_icon']} View Entire Diff.</a></p>";
        }
    }



    /**
     * Get the changelog file for the given module.
     *
     * Currently only knows about Github.
     */
    public function getChangelog($info, &$http, &$changelog) {
        $remote = $info['project_url'];
        $raw_remote = str_replace('https://github.com/', 'https://raw.githubusercontent.com/', $remote);
        $url = "$raw_remote/master/CHANGELOG.md";
        $result = $http->get($url);
        $this->recordRemainingReads($http);
        if(200 == $http->getHttpCode()) {
            $changelog = $result;
        }
    }



    /**
     * Examine the remote URL to determine the hosting service and icon to use.
     */
    public function remoteHostInfo($remote) {
        if (false !== stripos($remote, '://github.com')) {
            return array(
                'host' => 'Github',
                'link' => $remote,
                'icon' => '<i class="fa fa-icon fa-github"></i>',
            );
        } else if (false !== stripos($remote, '://bitbucket.org')) {
            return array(
                'host' => 'BitBucket',
                'link' => $remote,
                'icon' => '<i class="fa fa-icon fa-bitbucket"></i>'
            );
        } else if (false !== stripos($remote, '://gitlab.com')) {
            return array(
                'host' => 'GitLab',
                'link' => $remote,
                'icon' => '<i class="fa fa-icon fa-gitlab"></i>'
            );
        }

        // Use a generic git icon...
        return array(
            'host' => 'Unknown',
            'link' => $remote,
            'icon' => '<i class="fa fa-icon fa-git"></i>',
        );
    }



    /**
     * Pulls the x-ratelimit headers from Github.
     */
    protected function recordRemainingReads($http) {
        $headers = $http->getResponseHeaders();
        if (isset($headers['x-ratelimit-remaining'])) {
            $this->github_remaining_reads = array(
                'limit'     => $headers['x-ratelimit-limit'],
                'remaining' => $headers['x-ratelimit-remaining'],
                'reset'     => $headers['x-ratelimit-reset'],
            );
        }
    }


    /**
     * Pulls the last N commits for the given module.
     *
     * Currently only knows about Github.
     */
    public function getLastCommits($info, &$http, &$latest_commits) {
        $remote = $info['project_url'];
        $api_remote = str_replace('https://github.com/', 'https://api.github.com/repos/', $remote);
        $url = "$api_remote/commits";
        $result = $http->getJSON($url);
        $this->recordRemainingReads($http);
        $code = $http->getHttpCode();
        if(200 == $code && !empty($result)) {
            $history = array();
            $commits = array_slice($result, 0, $this->data['fallbackCommitHistory']);
            foreach ($commits as $commit) {
                $message   = $this->sanitizeString($commit['commit']['message']);
                $message   = wordwrap($message);
                $sig       = $this->formatCommitMetaData($commit, $info);
                $entry     = "<li>$sig<br><pre>$message</pre></li>";
                $history[] = $entry;
            }
            $history   = implode("", $history);
            $latest_commits = "<ul>$history</ul>";
        }
    }


    /**
     * Add hooks to display release information to modules prior to upgrade and add the readme and changelog to module
     * information pages.
     */
    public function ready() {

        /**
         * Inject common stylesheet into download confirm page
         */
        $this->addHookAfter("ProcessModule::execute", function($event) {
            $event->return = self::getEmbeddedStyles() . $event->return;
        });

        /**
         * Add Release notes and/or a list of commits between tags and/or the latest changelog and/or the latest
         * commit messages to the download confirmation form.
         */
        $this->addHookAfter("ProcessModule::buildDownloadConfirmForm", function($event) {
            $info            = $event->arguments[0];
            $module_class    = $info['class_name'];
            $current_info    = $this->modules->getModuleInfo($module_class);
            $current_version = $current_info['version'];
            $new_version     = $info['module_version'];
            $remote          = $info['project_url'];
            $remote_info     = $this->remoteHostInfo($remote);
            $repo_icon       = $remote_info['icon'];
            $remote_icon     = '<i class="fa fa-icon fa-external-link"></i>';
            $is_github_repo  = (false !== stripos($remote, '://github.com'));

            // Push the current version into the $info
            $info['version_current'] = $current_version;
            if (is_int($current_version)) {
                $current_version = $this->modules->formatVersion($current_version);
            }
            $info['module_version_current'] = $current_version;
            $info['repo_icon']   = $repo_icon;
            $info['remote_icon'] = $remote_icon;
            ksort($info);

            $changes         = $current_version != $new_version;
            $parsedown       = $this->modules->get('TextformatterParsedownExtraPlugin');
            if ($parsedown) {
                $fmt_note = __('Markdown formatted text shown');
            } else {
                $fmt_note = __('Raw text shown');
            }

            $http = new WireHttp();
            $http->setHeader('User-Agent', 'netcarver-pw-module-version-checker');
            $http->setTimeout(2);

            $return_info     = $event->return;
            $children        = $return_info->children;


            $wrapper = $this->modules->get('InputfieldFieldset');
            $wrapper->name  = 'changes-wrapper';
            $wrapper->label = __("What's Changed?");

            $release_notes  = $release_notes_default  = __('Not Available - Github Release Not Found');
            $tagged_log     = $tagged_log_default     = __('Not Available - Git Tags Missing');
            $changelog_file = $changelog_file_default = __('Not Available - File Missing');
            $latest_commits = $latest_commits_default = __('Comming Soon!');

            //
            // Fetch release notes (if any)...
            //
            // TODO Only show release notes for Github repos. BB and GL repos don't support them.
            //
            $tmp_release_notes = $this->getReleaseNotes($info, $http);
            $code = $http->getHttpCode();
            if(200 == $code && !empty($tmp_release_notes['body'])) {
                // TODO Handle non 200 return codes, or empty body!
                // TODO It is possible for the requests to be refused due to rate-limiting - this needs to be conveyed to the
                // user
                $message       = $this->sanitizeString($tmp_release_notes['body'], (bool)$parsedown);
                $release_notes = ($parsedown) ? $parsedown->parsedown($message) : "<pre>$message</pre>";
                $release_link  = "$remote/releases/tag/$new_version";
            }
            $has_release_notes = $release_notes != $release_notes_default;

            //
            // Fetch tagged log (if any)...
            //
            if ($changes) {
                $this->getTaggedLog($info, $http, $tagged_log);
            }
            $has_tagged_log = $tagged_log != $tagged_log_default;

            //
            // Fetch changelog file (if any)...
            //
            $this->getChangelog($info, $http, $changelog_file);
            $has_changelog_file = $changelog_file != $changelog_file_default;


            $field = $this->modules->get('InputfieldMarkup');
            $field->name = 'release-notes';
            if ($has_release_notes) {
                $field->label  = __("Official Release Notes for $new_version.");
                $release_notes = "<div class='module-release-notes'>$release_notes<p><a href='$release_link' target='_diff'>$repo_icon View</a><p></div>";
                $field->notes  = $fmt_note;
            } else {
                $field->label = __("No Official Release Notes for $new_version.");
                $field->notes = __('To add official release notes, please start using the Github [Releases](https://help.github.com/articles/creating-releases/) feature. You will have to start [tagging](https://git-scm.com/book/en/v2/Git-Basics-Tagging) your code as you push new versions in order to use this feature.');
                if ($has_changelog_file || $has_tagged_log) {
                    $field->collapsed = Inputfield::collapsedYes;
                }
            }
            $field->value = $release_notes;
            $wrapper->add($field);

            if ($changes) {
                $field = $this->modules->get('InputfieldMarkup');
                $field->name = 'tagged-log';
                if ($has_tagged_log) {
                    $field->label = __("Detailed Commit History - from $current_version to $new_version");
                } else {
                    $field->label = __("No Detailed Commit History Available");
                    $field->notes = __('Even if you don\'t use Github Releases, you can start to show code changes between versions if you start [tagging](https://git-scm.com/book/en/v2/Git-Basics-Tagging) each commit that increments your module version. Your tags **must** match your version numbering scheme for this feature to work - don\'t tag "v1.0.1" if your version in PW is ```101``` or ```"1.0.1"```.');
                    if ($has_changelog_file) {
                        $field->collapsed = Inputfield::collapsedYes;
                    }
                }
                if ($has_release_notes) {
                    $field->collapsed = Inputfield::collapsedYes;
                }
                $field->value = "<div class='module-release-notes'>$tagged_log</div>";
                $wrapper->add($field);
            }

            if (!$has_release_notes || $has_changelog_file) {
                // If there are no release notes, or there is a changelog file, we show this field.
                $field = $this->modules->get('InputfieldMarkup');
                $field->name = 'changelog';
                if ($has_changelog_file) {
                    $field->label   = __("Changelog from version $new_version");
                    $message        = $this->sanitizeString($changelog_file, (bool)$parsedown);
                    $changelog_file = ($parsedown) ? $parsedown->parsedown($message) : "<pre>$message</pre>";
                    $field->notes   = $fmt_note;
                    $changelog_file = "<div class='module-release-notes'>$changelog_file</div>";
                } else {
                    $field->label   = __("No Changelog from version $new_version");
                    $field->notes   = __('If you do not want to tag versions or cut releases, then please consider adding (and maintaining) a ```CHANGELOG.md``` file in the root of your module repository. If you do, it will show up here. If you already use the releases feature, or tag your versions, this is not necessary.');
                }
                if ($has_release_notes) {
                    $field->collapsed = Inputfield::collapsedYes;
                    $field->notes    .= __('You are already using the Releases feature and may be duplicating effort maintaining a ```CHANGELOG.md``` file as well. Perhaps it\'s time to remove the changelog file from your repository?');
                }
                $field->value = $changelog_file;
                $wrapper->add($field);
            }

            if (!$has_release_notes && !$has_tagged_log && !$has_changelog_file) {

                $this->getLastCommits($info, $http, $latest_commits);
                $has_latest_commits = $latest_commits != $latest_commits_default;

                $field = $this->modules->get('InputfieldMarkup');
                $field->name = 'commit-log';
                $field->label = $this->data['fallbackCommitHistory'] . ' ' . __("Most Recent Commits");
                if (!$has_latest_commits) {
                    $field->notes = __('Please consider adding support for one of the above options, as this list is simply the most recent Git commit message log. Adding and maintaining a ```CHANGELOG.md``` file is a step-up. Tagging your commits when you go to a new version is better still, as it allows automatic diffing between versions. The best option is to start using the Github Releases feature.');
                }
                $field->value = "<div class='module-release-notes'>$latest_commits</div>";
                $wrapper->add($field);
            }

            $wrapper->notes = __("Github API reads remaining: ") . $this->github_remaining_reads['remaining'] .'/'. $this->github_remaining_reads['limit'] . '. ' .
                __('Resets at ') .strftime('%F %T', $this->github_remaining_reads['reset']);

            $return_info->children->insertAfter($wrapper, $children[0]);
        });



        /**
         * Display README and CHANGELOG sections on all module information pages, if these files exist in the
         * installation. This allows access to a level of help for modules that wasn't there before.
         */
        $this->addHookAfter("ProcessModule::executeEdit", function($event){
            $info         = null;
            $module_class = '';

            if (isset($_POST['name'])) {
                $module_class = $_POST['name'];
            } elseif (isset($_GET['name'])) {
                $module_class = $_GET['name'];
            }

            $wrapper = $this->modules->get('InputfieldFieldset');
            $wrapper->name  = 'changes-wrapper';
            $wrapper->label = __("What's Changed?");

            $module_class = $this->sanitizer->name($module_class);
            $info = $this->modules->getModuleInfoVerbose($module_class);
            $dir = dirname(realpath($info['file']));
            $readmes = glob("$dir".DIRECTORY_SEPARATOR."README*");
            foreach ($readmes as $readme_filename) {
                $content = $this->getFormattedTextFromFile($readme_filename, $formatting_notes);
                if (!$content) continue;
                $wrapper->add(self::wrapValueInField('readme', $content, __('Readme File'), 'file-text-o', $formatting_notes));
            }

            $changelogs = glob("$dir".DIRECTORY_SEPARATOR."CHANGELOG*");
            foreach ($changelogs as $filename) {
                $content = $this->getFormattedTextFromFile($filename, $formatting_notes);
                if (!$content) continue;
                $wrapper->add(self::wrapValueInField('changelog', $content, __('Changelog File'), 'tags', $formatting_notes));
            }

            $module_page   = $event->return;
            $styles        = self::getEmbeddedStyles();
            $event->return = $styles. $wrapper->render() . $module_page;
        });
    }



    /**
     * Lists mappings of file extensions to markup language and preferred textformatter to be used.
     *
     * Anything not matching the list here (or if the formatter fails to be loaded) will be escaped and output
     * 'verbatim'.
     */
    static $formatters = array(
        'md'      => array('type' => 'Markdown', 'use' => 'TextformatterParsedownExtraPlugin'),
        //'textile' => array('type' => 'Textile',  'use' => 'TextformatterTextile'),
    );


    /**
     * Returns a formatter for the given file extension (if possible)
     */
    static function getFormatterForFiletype($ext, &$formatter_info) {
        $ext = strtolower($ext);
        if (empty($ext)) $ext = 'txt';
        $formatter_info = @self::$formatters[$ext];
        $formatter      = null; // null => no load tried. false => load tried and failed.
        if ($formatter_info) {
            $formatter = @$formatter_info['instance'];
            if (null === $formatter) {
                if (is_string($formatter_info['use']) && !empty($formatter_info['use'])) {
                    $formatter = wire('modules')->get($formatter_info['use']);
                }
                self::$formatters[$ext]['instance'] = ($formatter) ? $formatter: false;
            }
        }
        return $formatter;
    }


    /**
     * Given a filename, tries to read and format the content with an appropriate textformatter.
     */
    public function getFormattedTextFromFile($filename, &$transformation_applied) {
        $transformation_applied = __('None');
        if (!is_file($filename) || !is_readable($filename)) return false;
        // Which extension is the file using?
        $ext = strtolower(pathinfo($filename, PATHINFO_EXTENSION));
        if (empty($ext)) $ext = 'txt';
        $content = file_get_contents($filename);
        return (false !== $content) ? self::formatTextOfType($ext, $content, $transformation_applied) : false;
    }


    /**
     * Tries to apply an appropriate textformatter to a given content string.
     * If no suitable external formatter is available, it will be passed through an internal 'verbatim' formatter.
     *
     * It also records which formatter was applied.
     */
    static function formatTextOfType($ext, $content, &$transformation_applied) {
        $formatter = self::getFormatterForFiletype($ext, $formatter_info);
        if ($formatter) {
            /**
             * Display using formatter. Need to prevent possible XSS vectors here so it is all escaped...
             *
             * We call html_entity_decode() to convert entities to their UTF-8 character versions when possible,
             * before then passing it through htmlspecialchars() to encode angle brackets and quotes. If this is not
             * done then some characters with diacritic marks remain as html entities in the code.
             */
            $content = html_entity_decode($content, ENT_COMPAT, 'UTF-8');
            $content = htmlspecialchars($content, ENT_COMPAT, 'UTF-8');
            $formatter->formatValue(new \ProcessWire\Page(), new \ProcessWire\Field(), $content);
            $transformation_applied = sprintf(__("Prepared using the %s formatter."), $formatter_info['type']) . " [$ext]";
        } else {
            /**
             * Display verbatim. Need to prevent possible XSS vectors here so it is all escaped...
             */
            $content = htmlspecialchars($content, ENT_COMPAT, 'UTF-8');
            $content = "<pre>$content</pre>";

            if ($formatter_info) {
                /**
                 * formatter_info existing shows we had a textformatter entry for this filetype but couldn't load it
                 */
                $transformation_applied = sprintf(
                    __("Prepared using verbatim formatter because the %s formatter [%s] is not available."),
                    $formatter_info['type'],
                    $formatter_info['use']
                ) . " [$ext]";
            } else {
                $transformation_applied = __("Prepared using verbatim formatter.") . " [$ext]";
            }
        }
        return $content;
    }



    /**
     * TODO Only apply this stylesheet once on the admin page we are injecting into.
     */
    static function getEmbeddedStyles() {
        $value = <<<CSS
<style>
.module-release-notes {overflow-x:overlay;padding-bottom:1em}
.module-release-notes h1 {margin-top:1em !important; font-size:1.5em}
.module-release-notes h2 {margin-top: 1em}
.module-release-notes li {margin:0}
.module-release-notes ul {margin-bottom:2em}
</style>
CSS;

        return $value;
    }



    /**
     * Builds a markup input field to contain the given information.
     */
    static function wrapValueInField($name, $value, $label, $icon, $notes) {
        $value = "<div class='module-release-notes'>$value</div>";
        $f = wire('modules')->get('InputfieldMarkup');
        $f->name = $name;
        $f->label = $label;
        $f->notes = $notes;
        $f->value = $value;
        $f->collapsed = Inputfield::collapsedYes;
        $f->icon = $icon;
        return $f;
    }


    /**
     *
     */
    public function init() {
        parent::init();
    }



    /**
     *
     */
    static public function getModuleConfigInputfields(array $data) {

        $modules   = wire('modules');
        $fields    = new InputfieldWrapper();
        $defaults  = self::getDefaultConfig();
        $data      = array_merge($defaults, $data);

        $f = $modules->get('InputfieldInteger');
        $f->attr('name', 'fallbackCommitHistory');
        $f->attr('inputType', 'number');
        $f->attr('type', 'number');
        $f->label = __('Number of Commits To Show');
        $f->description = __('If there are no Release Notes, Tagged Commits or Changelog, how many lines of commit history should be shown?');
        $f->max = 30;
        $f->min = 2;
        $f->notes = __("Minimum 2, Maximum 30");
        $f->attr('value', $data['fallbackCommitHistory']);
        $fields->add($f);

        return $fields;
    }


    /**
     * Installs needed resources.
     */
    public function ___install() {
    }

}
