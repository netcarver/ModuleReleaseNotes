<?php

/**
 * ProcessWire
 * Copyright (C) 2014-present by Ryan Cramer
 * Licensed under GNU/GPL v2, see LICENSE.TXT
 *
 * http://processwire.com
 *
 *
 * TODO
 * ----
 * Add caching to help circumvent hitting hosting service API rate limits
 * Add support for Gitlab hosted repositories via repo-host abstraction
 * Add support for BitBucket hosted repositories via repo-host abstraction
 * Move support for GitHub into repo-host abstraction
 * Add public data-access API for other modules to use
 *
 * Known Issues
 * ------------
 *
 */

class ModuleReleaseNotes extends Process implements ConfigurableModule {


    protected $github_remaining_reads = 60;


    public static function getModuleInfo() {
        return [
            'title'     => __('Module Release Notes'),
            'summary'   => __("Discovers and shows what has changed with each module version."),
            'version'   => '0.7.4',
            'author'    => 'S Dickinson (netcarver)',
            'autoload'  => 'template=admin',
            'singular'  => true,
            'permanent' => false,
            'requires'  => 'ProcessWire>=3.0.0, PHP>=5.4.0',
            'installs'  => 'TextformatterParsedownExtraPlugin',
            'icon'      => 'code-fork',
        ];
    }


    /**
     *
     */
    static public function getDefaultConfig() {
        return [
            'fallbackCommitHistory' => 12,
            'openSettings'          => 0,
            'wordWrapColumn'        => 90,
            'breakingPhrases'       => 'BreakingChange, Breaking Change, Breaking-Change',
        ];
    }


    /**
     * Lists mappings of file extensions to markup language and preferred textformatter to be used.
     *
     * Anything not matching the list here (or if the formatter fails to be loaded) will be escaped and output
     * 'verbatim'.
     */
    static $formatters = [
        'md' => ['type' => 'Markdown', 'use' => 'TextformatterParsedownExtraPlugin'],
    ];


    /**
     * Make config data available within the instance variable.
     */
    public function __construct() {
        foreach(self::getDefaultConfig() as $key => $value) {
            $this->$key = $value;
        }
    }


    /**
     * Prepares commit meta-data for display
     */
    protected function formatCommitMetaData($commit, $info) {
        $author    = $commit['commit']['author']['name'];
        $committer = $commit['commit']['committer']['name'];
        $date      = $commit['commit']['committer']['date'];
        $sha       = substr($commit['sha'], 0, 8);
        $diff_url  = $commit['html_url'];
        $icon      = $info['repo_icon'];

        $date  = str_replace('T', ' ', $date);
        $sig   = "$icon &mdash; $date &mdash; <a href='$diff_url' target='_diff'>$sha <i class='fa fa-icon fa-external-link'></i></a> &mdash; $author";

        return $sig;
    }




    /**
     * Get githubs ReleaseNotes entry for the given module.
     */
    public function getReleaseNotes($info, &$http, &$release_notes, &$fmt_note) {
        // TODO add caching (stop us from hitting API request limits
        // Look for release notes
        $remote = $info['project_url'];
        $api_remote = str_replace('https://github.com/', 'https://api.github.com/repos/', $remote);
        $url = "$api_remote/releases/tags/{$info['module_version']}";
        $tmp_release_notes = $http->getJSON($url);
        $this->recordRemainingReads($http);
        $code = $http->getHttpCode();
        if(200 == $code && !empty($tmp_release_notes['body'])) {
            // TODO Handle non 200 return codes, or empty body!
            // TODO It is possible for the requests to be refused due to rate-limiting - this needs to be conveyed to the
            // user
            $release_notes_newtype = 'txt';
            $release_notes = $this->formatTextOfType('md', $tmp_release_notes['body'], $fmt_note, $release_notes_newtype);
        }
    }


    /**
     * Sanitise a string for further processing and display.
     */
    public function sanitizeString($string) {
        $san = wire('sanitizer');
        $string = $san->purify($string);
        return $string;
    }



    /**
     *
     */
    public function getTaggedLog($info, &$http, &$tagged_log) {
        // TODO add caching (stop us from hitting API request limits
        $remote = $info['project_url'];
        $api_remote = str_replace('https://github.com/', 'https://api.github.com/repos/', $remote);
        $url = "$api_remote/compare/{$info['module_version_current']}...{$info['module_version']}";
        $tmp_result = $http->getJSON($url);
        $this->recordRemainingReads($http);
        $code = $http->getHttpCode();
        if(200 == $code && !empty($tmp_result['commits'])) {
            $history = [];
            $commits = $tmp_result['commits'];
            foreach ($commits as $commit) {
                $message   = $this->sanitizeString($commit['commit']['message']);
                $message   = $this->utf8_wordwrap($message);
                $sig       = $this->formatCommitMetaData($commit, $info);
                $entry     = "<li class='commit'><span class='sig'>$sig</span><br><pre>$message</pre></li>";
                $history[] = $entry;
            }
            $history   = implode("", $history);
            $diff_url  = $tmp_result['html_url'];
            $diff_link = "(<a href='$diff_url' target='_diff'>View diff. {$info['remote_icon']}</i></a>)";
            $tagged_log = "<ul class='commits'>$history</ul><p><a href='$diff_url' target='_diff'>{$info['repo_icon']} View Entire Diff.</a></p>";
        }
    }



    /**
     * Get the changelog file for the given module.
     *
     * Currently only knows about Github.
     */
    public function getChangelog($info, &$http, &$changelog) {
        $remote = $info['project_url'];
        $raw_remote = str_replace('https://github.com/', 'https://raw.githubusercontent.com/', $remote);
        $url = "$raw_remote/master/CHANGELOG.md";
        $result = $http->get($url);
        $this->recordRemainingReads($http);
        if(200 == $http->getHttpCode()) {
            $changelog = $result;
        }
    }



    /**
     * Examine the remote URL to determine the hosting service and icon to use.
     */
    public function remoteHostInfo($remote) {
        if (false !== stripos($remote, '://github.com')) {
            return [
                'host' => 'Github',
                'link' => $remote,
                'icon' => '<i class="fa fa-icon fa-github"></i>',
            ];
        } else if (false !== stripos($remote, '://bitbucket.org')) {
            return [
                'host' => 'BitBucket',
                'link' => $remote,
                'icon' => '<i class="fa fa-icon fa-bitbucket"></i>'
            ];
        } else if (false !== stripos($remote, '://gitlab.com')) {
            return [
                'host' => 'GitLab',
                'link' => $remote,
                'icon' => '<i class="fa fa-icon fa-gitlab"></i>'
            ];
        }

        // Use a generic git icon...
        return [
            'host' => 'Unknown',
            'link' => $remote,
            'icon' => '<i class="fa fa-icon fa-git"></i>',
        ];
    }



    /**
     * Pulls the x-ratelimit headers from Github.
     */
    protected function recordRemainingReads($http) {
        $headers = $http->getResponseHeaders();
        if (isset($headers['x-ratelimit-remaining'])) {
            $this->github_remaining_reads = [
                'limit'     => $headers['x-ratelimit-limit'],
                'remaining' => $headers['x-ratelimit-remaining'],
                'reset'     => $headers['x-ratelimit-reset'],
            ];
        }
    }


    /**
     * Pulls the last N commits for the given module.
     *
     * Currently only knows about Github.
     */
    public function getLastCommits($info, &$http, &$latest_commits) {
        $remote = $info['project_url'];
        $api_remote = str_replace('https://github.com/', 'https://api.github.com/repos/', $remote);
        $url = "$api_remote/commits";
        $result = $http->getJSON($url);
        $this->recordRemainingReads($http);
        $code = $http->getHttpCode();
        if(200 == $code && !empty($result)) {
            $history = [];
            $commits = array_slice($result, 0, $this->data['fallbackCommitHistory']);
            foreach ($commits as $commit) {
                $message   = $this->sanitizeString($commit['commit']['message']);
                $message   = $this->utf8_wordwrap($message);
                $sig       = $this->formatCommitMetaData($commit, $info);
                $entry     = "<li class='commit'><span class='sig'>$sig</span><br><pre>$message</pre></li>";
                $history[] = $entry;
            }
            $history   = implode("", $history);
            $latest_commits = "<ul class='commits'>$history</ul>";
        }
    }


    /**
     * Add hooks to display release information to modules prior to upgrade and add the readme and changelog to module
     * information pages.
     */
    public function ready() {

        if (!$this->user->isLoggedin() || !$this->user->hasPermission('module-admin')) return;

        /**
         * Add Release notes and/or a list of commits between tags and/or the latest changelog and/or the latest
         * commit messages to the download confirmation form.
         */
        $this->addHookAfter("ProcessModule::buildDownloadConfirmForm", function($event) {
            $info            = $event->arguments[0];
            $module_class    = $info['class_name'];
            $current_info    = $this->modules->getModuleInfo($module_class);
            $current_version = $current_info['version'];
            $new_version     = $info['module_version'];
            $remote          = $info['project_url'];
            $remote_info     = $this->remoteHostInfo($remote);
            $repo_icon       = $remote_info['icon'];
            $remote_icon     = '<i class="fa fa-icon fa-external-link"></i>';
            $is_github       = 'Github' == $remote_info['host'];

            // Push the current version into the $info
            $info['version_current'] = $current_version;
            if (is_int($current_version)) {
                $current_version = $this->modules->formatVersion($current_version);
            }
            $info['module_version_current'] = $current_version;
            $info['repo_icon']   = $repo_icon;
            $info['remote_icon'] = $remote_icon;
            ksort($info);

            $changes         = $current_version != $new_version;

            $http = new WireHttp();
            $http->setHeader('User-Agent', 'netcarver-pw-module-version-checker');
            $http->setTimeout(2);

            $return_info     = $event->return;
            $children        = $return_info->children;


            $wrapper = $this->modules->get('InputfieldFieldset');
            $wrapper->name  = 'changes-wrapper';
            $wrapper->label = __("What's Changed?");

            $release_notes  = $release_notes_default  = __('Not Available - Github Release Notes Not Found');
            $tagged_log     = $tagged_log_default     = __('Not Available - One or More Git Tags Missing');
            $changelog_file = $changelog_file_default = __('Not Available - File Missing');
            $latest_commits = $latest_commits_default = __('Comming Soon!');

            //
            // Fetch release notes...
            //
            if ($changes && $is_github) {
                $this->getReleaseNotes($info, $http, $release_notes, $fmt_note);
                $release_link  = "$remote/releases/tag/$new_version";
            }
            $has_release_notes = $release_notes != $release_notes_default;

            //
            // Fetch tagged log (if any)...
            //
            if ($changes) {
                $this->getTaggedLog($info, $http, $tagged_log);
            }
            $has_tagged_log = $tagged_log != $tagged_log_default;

            //
            // Fetch changelog file (if any)...
            //
            $this->getChangelog($info, $http, $changelog_file);
            $has_changelog_file = $changelog_file != $changelog_file_default;


            if ($is_github && $changes) {
                $field = $this->modules->get('InputfieldMarkup');
                $field->name = 'release-notes';
                if ($has_release_notes) {
                    $field->label  = sprintf(__("Github Release Notes for version %s."), $new_version);
                    $release_notes = "<div class='release-notes'>$release_notes<p><a href='$release_link' target='_diff'>$repo_icon View</a><p></div>";
                    if ($this->config->debug) $field->notes = $fmt_note;
                } else {
                    $field->label = sprintf(__("No Github Release Notes for version %s."), $new_version);
                    $field->notes = __('To add official release notes, please ask the module author to start using the Github [Releases](https://help.github.com/articles/creating-releases/) feature. They will have to start [tagging](https://git-scm.com/book/en/v2/Git-Basics-Tagging) the code as they push new versions in order to use this feature.');
                    $field->collapsed = Inputfield::collapsedYes;
                }
                $field->value = $release_notes;
                $wrapper->add($field);
            }

            if ($changes) {
                $field = $this->modules->get('InputfieldMarkup');
                $field->name = 'tagged-log';
                if ($has_tagged_log) {
                    $field->label = sprintf(__("Tag-to-Tag Commit History - from version %s to %s"), $current_version, $new_version);
                } else {
                    $field->label = __("No Tag-to-Tag Commit History Available");
                    $field->notes = __('If the author doesn\'t use Github Releases, they can start to show code changes between versions if they start [tagging](https://git-scm.com/book/en/v2/Git-Basics-Tagging) each commit that increments the module version. **This helps the reader as it limits the listed commits to those representing changes.** The tags must match the version numbering scheme used by the module for this feature to work.');
                    if ($has_changelog_file) {
                        $field->collapsed = Inputfield::collapsedYes;
                    }
                }
                if ($has_release_notes) {
                    $field->collapsed = Inputfield::collapsedYes;
                }
                $field->value = "<div class='release-notes'>$tagged_log</div>";
                $wrapper->add($field);
            }

            if (!$has_release_notes || $has_changelog_file) {
                // If there are no release notes, or there is a changelog file, we show this field.
                $field = $this->modules->get('InputfieldMarkup');
                $field->name = 'changelog';
                if ($has_changelog_file) {
                    $field->label   = sprintf(__("Changelog from remote version %s"), $new_version);
                    $changelog_newtype = 'txt';
                    $changelog_file = $this->formatTextOfType('md', $changelog_file, $fmt_note, $changelog_newtype);
                    $changelog_file = $this->insertMarkerForVersion($current_version, $changelog_file, $changelog_newtype, $new_version);
                    $changelog_file = "<div class='release-notes'>$changelog_file</div>";
                    if ($this->config->debug) $field->notes = $fmt_note;
                } else {
                    $field->label   = sprintf(__("No Changelog from remote version %s"), $new_version);
                    $field->notes   = __('If the author does not want to tag versions or create Github Releases, then they could consider adding (and maintaining) a ```CHANGELOG``` file in the root of the module repository. If they do, it will show up here. If they already use the releases feature, or tag module versions, this is not necessary and can lead to duplicated effort.');
                    $field->collapsed = Inputfield::collapsedYes;
                }
                $field->value = $changelog_file;
                $wrapper->add($field);
            }

            if (!$has_release_notes && !$has_tagged_log && !$has_changelog_file) {

                $this->getLastCommits($info, $http, $latest_commits);
                $has_latest_commits = $latest_commits != $latest_commits_default;

                $field = $this->modules->get('InputfieldMarkup');
                $field->name = 'commit-log';
                $field->label = $this->data['fallbackCommitHistory'] . ' ' . __("Most Recent Commits");
                if (!$has_latest_commits) {
                    $field->notes = __('Please ask the author to add support for one of the above options, as this list is simply the most recent Git commit message log. Adding and maintaining a ```CHANGELOG.md``` file is a step-up. Tagging git commits at each new version is better still, as it allows automatic diffing between versions. If on Github, using the Releases feature is a nice step up.');
                }
                $field->value = "<div class='release-notes'>$latest_commits</div>";
                $wrapper->add($field);
            }

            if ($this->config->debug) {
                $wrapper->notes = __("Github API reads remaining: ") . $this->github_remaining_reads['remaining'] .'/'. $this->github_remaining_reads['limit'] . '. ' .
                    __('Resets at ') .strftime('%F %T', $this->github_remaining_reads['reset']);
            }

            $return_info->children->insertAfter($wrapper, $children[0]);
        });



        /**
         * Display README and CHANGELOG sections on all module information pages, if these files exist in the
         * installation. This allows access to a level of help for modules that wasn't there before.
         */
        $this->addHookAfter("ProcessModule::executeEdit", function($event) {
            $info         = null;
            $module_class = '';
            $append_info  = false;

            if (isset($_POST['name'])) {
                $module_class = $_POST['name'];
            } elseif (isset($_GET['name'])) {
                $module_class = $_GET['name'];
            }
            $module_class = $this->sanitizer->name($module_class);
            $info = $this->modules->getModuleInfoVerbose($module_class);

            $outer_wrapper = new InputfieldWrapper();
            $wrapper = $this->modules->get('InputfieldFieldset');
            $wrapper->id    = 'module-release-notes-fieldset';
            $wrapper->name  = 'changes-wrapper';
            $wrapper->label = __("Support Files");
            $wrapper->icon  = 'book';
            $wrapper->collapsed = $this->data['openSettings'] ? Inputfield::collapsedNo : Inputfield::collapsedYes;
            $outer_wrapper->add($wrapper);

            $dir = dirname(realpath($info['file']));

            $append_info |= $this->addSupportFiles('readme',    'file-text-o',   $wrapper, $dir.DIRECTORY_SEPARATOR."[Rr][Ee][Aa][Dd][Mm][Ee]*");
            $append_info |= $this->addSupportFiles('changelog', 'tags',          $wrapper, $dir.DIRECTORY_SEPARATOR."[Cc][Hh][Aa][Nn][Gg][Ee][Ll][Oo][Gg]*");
            $append_info |= $this->addSupportFiles('license',   'balance-scale', $wrapper, $dir.DIRECTORY_SEPARATOR."[Ll][Ii][Cc][Ee][Nn][SsCc][Ee]*");

            if ($append_info) {
                $event->return = $outer_wrapper->render() . $event->return;
            }
        });
    }


    /**
     * Searches for all files matching the given glob and attempts to read and format the contents of any
     * matches. These are added to the given wrapper.
     */
    protected function addSupportFiles($section, $icon, &$wrapper, $glob_regex) {
        $append_info = false;
        $files = glob($glob_regex);
        foreach ($files as $filename) {
            $newtype = 'txt';
            $content = $this->getFormattedTextFromFile($filename, $formatting_notes, $newtype);
            if (!$content) continue;
            $basename = basename($filename);
            if (!$this->config->debug) $formatting_notes = '';
            $wrapper->add(self::wrapValueInField($section, $content, $basename, $icon, $formatting_notes));
            $append_info = true;
        }
        return $append_info;
    }



    /**
     * Returns a formatter for the given file extension (if possible)
     */
    static function getFormatterForFiletype($ext, &$formatter_info) {
        $ext = strtolower($ext);
        if (empty($ext)) $ext = 'txt';
        $formatter_info = @self::$formatters[$ext];
        $formatter      = null; // null => no load tried. false => load tried and failed.
        if ($formatter_info) {
            $formatter = @$formatter_info['instance'];
            if (null === $formatter) {
                if (is_string($formatter_info['use']) && !empty($formatter_info['use'])) {
                    $formatter = wire('modules')->get($formatter_info['use']);
                }
                self::$formatters[$ext]['instance'] = ($formatter) ? $formatter: false;
            }
        }
        return $formatter;
    }


    /**
     * Given a filename, tries to read and format the content with an appropriate textformatter.
     */
    public function getFormattedTextFromFile($filename, &$transformation_applied, &$newtype) {
        $transformation_applied = __('None');
        if (!is_file($filename) || !is_readable($filename)) return false;
        // Which extension is the file using?
        $ext = strtolower(pathinfo($filename, PATHINFO_EXTENSION));
        if (empty($ext)) $ext = 'txt';
        $content = file_get_contents($filename);
        if (false !== $content && !empty(trim($content))) {
            $tmpval  = $newtype;
            $tmp     = $this->formatTextOfType($ext, $content, $transformation_applied, $tmpval);
            $tmp     = self::addExpansionWrapper($tmp, __('Show All'), 'long', 'full-height');
            $newtype = $tmpval;
            return $tmp;
        }
        return false;
    }


    /**
     * UTF-8 wordwrapping function.
     *
     * Source: http://php.net/manual/en/function.wordwrap.php#107570
     * minor edit to correct variable $search name in else clause.
     */
    protected function utf8_wordwrap($string, $break="\n", $cut=false) {
        $width = $this->wordWrapColumn;
        if($cut) {
            // Match anything 1 to $width chars long followed by whitespace or EOS,
            // otherwise match anything $width chars long
            $search  = '/(.{1,'.$width.'})(?:\s|$)|(.{'.$width.'})/uS';
            $replace = '$1$2'.$break;
        } else {
            // Anchor the beginning of the pattern with a lookahead
            // to avoid crazy backtracking when words are longer than $width
            $search  = '/(?=\s)(.{1,'.$width.'})(?:\s|$)/uS';
            $replace = '$1'.$break;
        }
        return preg_replace($search, $replace, $string);
    }



    /**
     * Demotes first H1 element to an H2.was-h1 element. The H1 must start at the beginning of a line.
     * Strips all attributes from the H1.
     */
    protected function changeH1toH2($content) {
        $regex = '^<h1([^>]*)>(.*)<\/h1>';
        $content = preg_replace("~$regex~i", "<h2 class=was-h1>$2</h2>", $content, 1);
        return $content;
    }


    /**
     * The github flavored markdown seems to allow for fenced codeblocks with mutliple language definitions.
     * Our versions of markdown don't seem to be able to cope with this, so simplify to first language (if any)
     */
    protected function prepareMarkdownCodeFences($content) {
        $regex = '^```([a-z0-9-_]*).*$';
        $content = preg_replace("~$regex~im", "```$1", $content);
        return $content;
    }



    /**
     * Tries to apply an appropriate textformatter to a given content string.
     * If no suitable external formatter is available, it will be passed through an internal 'verbatim' formatter.
     *
     * It also records which formatter was applied.
     */
    protected function formatTextOfType($ext, $unsafe_content, &$transformation_applied, &$newtype) {
        $transforms = [];
        $reason     = '';
        $formatter  = self::getFormatterForFiletype($ext, $formatter_info);
        if (true && ($formatter || ($formatter_info && $ext == 'md'))) {
            $unsafe_content = $this->prepareMarkdownCodeFences($unsafe_content);
            $transforms[] = __('Simplify Markdown codeblocks');
            if ($formatter) {
                // Attempt to use preferred formatter.
                $formatter->formatValue(new \ProcessWire\Page(), new \ProcessWire\Field(), $unsafe_content);
                $transforms[] = $formatter_info['type'];
            } else {
                // Fallback to using PW's own entitiesMarkdown sanitiser...
                $unsafe_content = $this->sanitizer->entitiesMarkdown($unsafe_content, true);
                $transforms[] = __('PW EntitiesMarkdown');
            }
            $content = $this->sanitizeString($unsafe_content);
            $transforms[] = __('HTML Purifier');
            $content = $this->changeH1toH2($content);
            $transforms[] = __('Demote h1 to h2');
            $newtype = 'html';
        } else {
            /**
             * Display verbatim. Need to prevent possible XSS vectors here so it is all escaped...
             *
             * We call html_entity_decode() to convert entities to their UTF-8 character versions when possible,
             * before then passing it through htmlspecialchars() to encode angle brackets and quotes. If this is not
             * done then some characters with diacritic marks remain as html entities in the code.
             */
            $content = html_entity_decode($unsafe_content, ENT_COMPAT, 'UTF-8');
            $transforms[] = __('HTML Entity Decode');
            $content = htmlspecialchars($content, ENT_COMPAT, 'UTF-8');
            $transforms[] = __('HTML Special Character Encode');
            $content = $this->utf8_wordwrap($content);
            $transforms[] = __('UTF8 Wordwrap');
            $content = "<pre>$content</pre>";

            if ($formatter_info) {
                /**
                 * formatter_info existing shows we had a textformatter entry for this filetype but couldn't load it
                 */
                $reason = sprintf(
                    __(" because the %s formatter [%s] is not available"),
                    $formatter_info['type'],
                    $formatter_info['use']
                );
                $newtype = strtolower($formatter_info['type']);
            }
        }
        $transforms = implode(' &rarr; ', $transforms);
        $transformation_applied = sprintf(__("Prepared text (type '%s') using the ```%s``` format chain%s."), $ext, $transforms, $reason);
        return $content;
    }



    protected function highlightBreakingChanges($changes, &$flag) {
        $breaking_changes = explode(',', $this->breakingPhrases);
        foreach ($breaking_changes as $bp) {
            $bp = trim($bp);
            $pos = stripos($changes, $bp);
            if (false !== $pos) {
                $flag |= true;
                $changes = str_ireplace($bp,  "<span class='breaking-change'>$bp</span>", $changes);
            }
        }

        return $changes;
    }


    static $cut_regexes = [
        'html'     => [
            'heading' => '(<h2 class=was-h1>[^<]*</h2>)',
            'version' => '(<h[2-3][^>]*>%s\b.*)$',
        ],
        'markdown' => [
            'pre'     => '<pre>',
            'post'    => '</pre>',
            'heading' => '^(# .*)$',
            'version' => '(#{2,3} %s\b.*)$',
        ],
    ];


    protected function insertMarkerForVersion($version, $changelog, $type, $latest_version = false) {
        $str_high = __("Latest");
        $str_low  = __("Installed");
        $pre       = '';
        $post      = '';
        $heading   = '';

        // Slice off the <pre> and </pre> in case this is a raw, or unformatted MD file...
        if (0 === stripos($changelog, '<pre>')) {
            $pre = '<pre>';
            $changelog = substr($changelog, 5);
        }
        if ('</pre>' === strtolower(substr($changelog, -6))) {
            $post = '</pre>';
            $changelog = substr($changelog, 0, -6);
        }

        $new_class = '';
        $newstuff  = '';

        // Slice off, and preserve the first "h2.was-h1" or "# h1 title" element.
        $heading_regex = @self::$cut_regexes[$type]['heading'];
        if (!empty($heading_regex)) {
            $heading_regex = "~$heading_regex~imU";
            $parts     = preg_split($heading_regex, $changelog, 3, PREG_SPLIT_DELIM_CAPTURE | PREG_SPLIT_NO_EMPTY);
            if (count($parts) > 1) {
                $heading   = array_shift($parts);
                $heading   = "<div class='heading has-gutter from-$type'>$heading</div>";
                $changelog = trim(implode('', $parts));
            }
        }

        $version_master_regex = @self::$cut_regexes[$type]['version'];
        if (!empty($version_master_regex)) {
            // Insert a marker for latest version (if given).
            if (is_string($latest_version) && !empty($latest_version)) {
                $version_regex = sprintf($version_master_regex, preg_quote($latest_version));
                $changelog     = preg_replace("~$version_regex~imU", "<span class='annotation arrow-box arrow-box-latest'>$str_high</span>\$1", $changelog, 1);
            }

            // Insert marker for the version we are currently on...
            $version_regex = sprintf($version_master_regex, preg_quote($version));
            $changelog     = preg_replace("~$version_regex~imU", "<span class='annotation arrow-box arrow-box-current'>$str_low</span>\$1", $changelog, 1);

            // Divide the remaining document into the new and old portions. Classes on the divs are used to control
            // the display of the result.
            $entries   = preg_split("~$version_regex~imU", $changelog, -1, PREG_SPLIT_DELIM_CAPTURE);
            $newstuff  = array_shift($entries);
            $newstuff .= array_shift($entries);
            $oldstuff  = implode('', $entries);
            $new_class = "new-changes has-gutter from-$type";
            $has_breaking_change = false;
            $newstuff = $this->highlightBreakingChanges($newstuff, $has_breaking_change);
            if ($has_breaking_change) {
                $new_class .= ' breaking-change';
            }
            $newstuff   = "<div class='$new_class'>$newstuff</div>";
            $wrap_class = "old-changes has-gutter from-$type";
        } else {
            $oldstuff   = $changelog;
            $wrap_class = 'all-changes';
        }

        // Rebuild the changelog with the divisions in place...
        $grow_label = __('Show More');
        $oldstuff   = self::addExpansionWrapper($oldstuff, $grow_label, $wrap_class);
        $changelog  = "$pre$heading$newstuff$oldstuff$post";
        return $changelog;
    }


    /**
     * Wrap the given content with a height-limiting wrapper and provide a link that expands it when clicked.
     */
    static protected function addExpansionWrapper($content, $label, $expand_class='', $link_class='grow-height') {
        return "<div class='expansion-wrapper'><div class='$expand_class expand'>$content</div><p class='expand-control'><a class='cursor-pointer $link_class'>$label</a></p></div>";
    }


    /**
     * Builds a markup input field to contain the given information.
     */
    static protected function wrapValueInField($name, $value, $label, $icon, $notes) {
        $value = "<div class='release-notes'>$value</div>";
        $f = wire('modules')->get('InputfieldMarkup');
        $f->name = $name;
        $f->label = $label;
        if (!empty(trim($notes))) $f->notes = $notes;
        $f->value = $value;
        $f->collapsed = Inputfield::collapsedYes;
        $f->icon = $icon;
        return $f;
    }


    /**
     *
     */
    public function init() {
        parent::init();
    }



    /**
     *
     */
    static public function getModuleConfigInputfields(array $data) {

        $modules   = wire('modules');
        $fields    = new InputfieldWrapper();
        $defaults  = self::getDefaultConfig();
        $data      = array_merge($defaults, $data);

        $f = $modules->get('InputfieldInteger');
        $f->attr('name', 'fallbackCommitHistory');
        $f->attr('inputType', 'number');
        $f->attr('type', 'number');
        $f->label = __('Number of Commits To Show');
        $f->description = __('If there are no Release Notes, Tagged Commits or Changelog, how many lines of commit history should be shown?');
        $f->max = 30;
        $f->min = 2;
        $f->notes = __("Minimum 2, Maximum 30");
        $f->attr('value', $data['fallbackCommitHistory']);
        $fields->add($f);

        $f = $modules->get('InputfieldText');
        $f->attr('name', 'breakingPhrases');
        $f->label = __('Breaking Changes');
        $f->description = __('A comma-separated list of phrases that indicate a breaking-change may be present.');
        $f->notes = __("The search for these phrases in changes will be case-insensitive.");
        $f->attr('value', $data['breakingPhrases']);
        $fields->add($f);

        $f = $modules->get('InputfieldInteger');
        $f->attr('name', 'wordWrapColumn');
        $f->attr('inputType', 'number');
        $f->attr('type', 'number');
        $f->label = __('Wrap text files at which column position?');
        $f->max = 300;
        $f->min = 40;
        $f->notes = __("Minimum 40, Maximum 300");
        $f->attr('value', $data['wordWrapColumn']);
        $fields->add($f);

        $f = $modules->get('InputfieldRadios');
        $f->attr('name', 'openSettings');
        $f->label = __('Open the "Support Files" section of the module information page automatically');
        $f->addOption(0, __('No, keep it collapsed.'));
        $f->addOption(1, __('Yes, show me a list of support files.'));
        $f->attr('value', $data['openSettings']);
        $fields->add($f);


        return $fields;
    }


    /**
     * Installs needed resources.
     */
    public function ___install() {
    }

}
